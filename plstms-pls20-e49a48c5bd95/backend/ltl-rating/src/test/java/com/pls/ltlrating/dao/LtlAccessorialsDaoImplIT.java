package com.pls.ltlrating.dao;import java.util.Arrays;import java.util.Calendar;import java.util.Date;import java.util.List;import org.junit.Assert;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import com.pls.core.common.utils.DateUtility;import com.pls.core.dao.AbstractDaoTest;import com.pls.core.exception.EntityNotFoundException;import com.pls.core.shared.Status;import com.pls.ltlrating.dao.impl.LtlAccessorialsDaoImpl;import com.pls.ltlrating.domain.LtlAccessorialsEntity;import com.pls.ltlrating.domain.bo.AccessorialListItemVO;import com.pls.ltlrating.shared.TestDataHelper;/** * Test cases for {@link LtlAccessorialsDaoImpl} class. * * Looking at here is the type of data we store and retrieve: * * 1. Selecting accessorial is mandatory. * 2. An accessorial can be blocked or unblocked and if it is blocked, it cannot be used temporarily. * 3. Cost : User can set up cost based on cost type and weight or distance or both. * 4. Margin : User can set up margin based on margin type weight or distance or both. User can also set * minimum margin percent or fixed margin amount. * 5. Effective Date is required and Expiration date is optional. Effective date should be defaulted to * current date if not available. * 6. Note is optional. * 7. Origin and Destination also are optional and they hold either State Code, or Complete Zip code ranges, * or 3 digit Zip code ranges, or 3 digit single zip codes or 5 digit single zip code. * These are the origins and destinations to which this accessorial and rate is applicable * * Each scenario that can be possible with this type of data is defined at each testcase level and tested the same. * * We need try creating accessorial with different types of data thinking as user because some type of data may fail * and also this helps to understand if we had set unique or not null constraints and need to fix them. * Even in future will help us to know if any additional constraint (not null for example) is added and if not * required, the testcase will fail. Then based on actual business scenario, either we have to fix testcases * or table definitions and constraints * * List of Dao methods that need to be covered: * ---------------------------------------------- * saveOrUpdate(LtlAccessorialsEntity) -- This is available in AbstractDaoImpl class * findByPrimaryKey(Long id) * updateAccessorialStatus(Long id, Status status) * findAllByProfileDetailId(Long profileDetailId) * findAllByStatusAndProfileDetailId(Long profileDetailId, Status status) * findActiveAndEffectiveByProfileDetailId(Long profileDetailId) * findExpiredByProfileDetailId(Long profileDetailId) * * @author Hima Bindu Challa */public class LtlAccessorialsDaoImplIT extends AbstractDaoTest {    @Autowired    private LtlAccessorialsDao sut;    private static final Long MODIFIED_BY = 1L;    private static final Long PROFILE_DETAIL_ID = 1L;    private static final Long CHILD_PROFILE_DETAIL_ID = 9L;    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Lets start with minimal data assuming user enters minimum data.     * So here minimum data required is "Accessorial Type", "One Cost Information (Cost per mile)",     * "One Margin Information (Cost per mile)", Effective Date.     */    @Test    public void testCreateAccessorialWithMinimalRequiredData() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setCostApplMinWt(null);        newEntity.setCostApplMaxWt(null);        newEntity.setCostApplMinDist(null);        newEntity.setCostApplMaxDist(null);        newEntity.setMarginPercent(null);        newEntity.setMarginDollarAmt(null);        newEntity.setExpDate(null);        newEntity.setNotes(null);        newEntity.setLtlAccGeoServicesEntities(null);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorial(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * This testcase inserts complete information on accessorials and validates the same.     */    @Test    public void testCreateAccessorialWithCompleteData() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test whole accessorial information for every origin and destination.     */    @Test    public void testCreateExpiredAccessorial() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setLtlAccGeoServicesEntities(null);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorial(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with minimum cost information for minimum weight, no distance and     * no minimum margin information.     */    @Test    public void testCreateAccessorialWithMinCostAndMargin() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setCostApplMinDist(null);        newEntity.setCostApplMaxDist(null);        newEntity.setMarginPercent(null);        newEntity.setMarginDollarAmt(null);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with minimum cost information for minimum distance, no weight and     * with only minimum margin information.     */    @Test    public void testCreateAccessorialWithMinCostAndNoMargin() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setCostApplMinWt(null);        newEntity.setCostApplMaxWt(null);        newEntity.setMarginType(null);        newEntity.setUnitMargin(null);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with past effective date and future expiration date.     */    @Test    public void testCreateAccessorialWithPastEffAndFutureExpDate() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -10));        newEntity.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, 15));        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with future effective date and future expiration date.     */    @Test    public void testCreateAccessorialWithFutureEffAndFutureExpDate() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, 5));        newEntity.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, 10));        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with past effective date and past expiration date.     */    @Test    public void testCreateAccessorialWithPastEffAndPastExpDate() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -15));        newEntity.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, -10));        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with different Accessorial Type, Blocked = Yes, Cost Type - 100 Weight,     * Margin Type - 100 Weight, Cost UOM and Distance UOM.     */    @Test    public void testCreateAccessorialSet2() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setBlocked(TestDataHelper.BLOCKED_YES);        newEntity.setAccessorialType(TestDataHelper.ACCESSORIAL_TYPE_RESIDENTIAL);        newEntity.setCostType(TestDataHelper.COST_TYPE_PER_100_WT);        newEntity.setCostApplWtUom(TestDataHelper.COST_APPL_WT_UOM_KG);        newEntity.setCostApplDistUom(TestDataHelper.COST_APPL_DIST_UOM_KM);        newEntity.setMarginType(TestDataHelper.MARGIN_TYPE_PER_100_WT);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with different Accessorial Type, Cost Type - Per Mile, Margin Type - Per Mile.     */    @Test    public void testCreateAccessorialSet3() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setAccessorialType(TestDataHelper.ACCESSORIAL_TYPE_INSIDE_DELIVERY);        newEntity.setCostType(TestDataHelper.COST_TYPE_PER_MILE);        newEntity.setMarginType(TestDataHelper.MARGIN_TYPE_PER_MILE);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with different Accessorial Type, Cost Type - Per Piece.     */    @Test    public void testCreateAccessorialSet4() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setAccessorialType(TestDataHelper.ACCESSORIAL_TYPE_INSIDE_PICKUP);        newEntity.setCostType(TestDataHelper.COST_TYPE_PER_PIECE);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * AbstractDaoImpl DAO Method: saveOrUpdate(Type entity).     *     * Testcase to test with different Accessorial Type, Cost Type - Percent, Margin Type - Percent.     */    @Test    public void testCreateAccessorialSet5() {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        newEntity.setAccessorialType(TestDataHelper.ACCESSORIAL_TYPE_APPOINTMENT);        newEntity.setCostType(TestDataHelper.COST_TYPE_FLAT_FEE);        newEntity.setMarginType(TestDataHelper.MARGIN_TYPE_PERCENT);        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);    }    /**     * DAO Method: updateAccessorialStatus(Long id, Status status, Long modifiedBy).     *     * Testcase to test updating accessorial status from "Active" to "Inactive"     */    @Test    public void testUpdateAccessorialStatus() throws EntityNotFoundException {        LtlAccessorialsEntity newEntity = TestDataHelper.createLTLAccessorial();        Assert.assertNull(newEntity.getId());        newEntity = sut.saveOrUpdate(newEntity);        assertCreatedAccessorialWithGeoServices(newEntity);        //Change Accessorial Status from Active to Inactive by calling updateAccessorialStatus        sut.updateStatuses(Arrays.asList(newEntity.getId()), Status.INACTIVE, MODIFIED_BY);        flushAndClearSession();        //get updated accessorial by primary key.        newEntity = sut.find(newEntity.getId());        //Test if the accessorial status is updated.        Assert.assertEquals(TestDataHelper.STATUS_INACTIVE, newEntity.getStatus());        assertUpdatedModificationObjectOfAccessorial(newEntity);    }    /**     * DAO Method: findAllByProfileDetailId(Long profileDetailId).     *     * Testcase to test findAllByProfileDetailId() Dao method. Will test with two different profile Ids - 1000, 1001     * and see if the method returns expected number of results and if the results match.     */    @Test    public void testFindAllByProfileDetailId() {        List<LtlAccessorialsEntity> existingLtlAccEntities2 =                sut.findAllByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_2);        LtlAccessorialsEntity newEntity1 = TestDataHelper.createLTLAccessorial();        newEntity1 = sut.saveOrUpdate(newEntity1);        LtlAccessorialsEntity newEntity2 = TestDataHelper.createLTLAccessorial();        newEntity2 = sut.saveOrUpdate(newEntity2);        LtlAccessorialsEntity newEntity3 = TestDataHelper.createLTLAccessorial();        newEntity3 = sut.saveOrUpdate(newEntity3);        LtlAccessorialsEntity newEntity4 = TestDataHelper.createLTLAccessorial();        newEntity4 = sut.saveOrUpdate(newEntity4);        LtlAccessorialsEntity newEntity5 = TestDataHelper.createLTLAccessorial();        newEntity5 = sut.saveOrUpdate(newEntity5);        flushAndClearSession();        //get updated accessorial by pricing profile detail Id.        List<LtlAccessorialsEntity> ltlAccEntities1 =                sut.findAllByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities1);        //Lets first check if the entities count is same. Should be 5        //TODO: Temporary fix        Assert.assertEquals(30, ltlAccEntities1.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(0), newEntity1);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(1), newEntity2);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(2), newEntity3);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(3), newEntity4);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(4), newEntity5);        // So far so good. Now lets create another set with different pricing profile detail Id        LtlAccessorialsEntity newEntity11 = TestDataHelper.createLTLAccessorial();        newEntity11.setLtlPricProfDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_2);        newEntity11 = sut.saveOrUpdate(newEntity11);        LtlAccessorialsEntity newEntity12 = TestDataHelper.createLTLAccessorial();        newEntity12.setLtlPricProfDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_2);        newEntity12 = sut.saveOrUpdate(newEntity12);        LtlAccessorialsEntity newEntity13 = TestDataHelper.createLTLAccessorial();        newEntity13.setLtlPricProfDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_2);        newEntity13 = sut.saveOrUpdate(newEntity13);        flushAndClearSession();        //get updated accessorial by pricing profile detail Id.        List<LtlAccessorialsEntity> ltlAccEntities2 =                sut.findAllByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_2);        Assert.assertNotNull(ltlAccEntities2);        //Lets first check if the entities count is same. Should be 3        //TODO: Temporary fix        ltlAccEntities2.removeAll(existingLtlAccEntities2);        Assert.assertEquals(18, ltlAccEntities2.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(0), newEntity11);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(1), newEntity12);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(2), newEntity13);    }    /**     * DAO Method: findAllByStatusAndProfileDetailId(Long profileDetailId, Status status).     *     * Testcase to test findAllByStatusAndProfileDetailId() Dao method. Will test with first creating profile     * details with active status and retrieving them using active status. Next update 2 records with inactive     * status and retrieve the record with active and inactive status separately. They should return 3 active     * records and 2 inactive records.     */    @Test    public void testFindAllByStatusAndProfileDetailId() throws EntityNotFoundException {        List<AccessorialListItemVO> actualList = sut.findAllByStatusAndProfileDetailId(PROFILE_DETAIL_ID, Status.ACTIVE);        Assert.assertNotNull(actualList);        Assert.assertFalse(actualList.isEmpty());        for (AccessorialListItemVO entity : actualList) {            Assert.assertNotNull(entity);            Assert.assertEquals(Status.ACTIVE.getCode(), entity.getStatus());        }    }    /**     * DAO Method: findActiveAndEffectiveByProfileDetailId(Long profileDetailId).     *     * Testcase to test findActiveAndEffectiveByProfileDetailId() Dao method.     * Will test with first creating profile details with active status and no expiration date and retrieving them     * using this method by pricing profile detail Id. Next update 2 records with inactive status and     * retrieve the records using this method again. Should return only 3. Now expire one active record and again     * retrieve records using this method. Should return only 2 records.     */    @Test    public void testFindActiveAndEffectiveByProfileDetailId() throws EntityNotFoundException {        LtlAccessorialsEntity newEntity1 = TestDataHelper.createLTLAccessorial();        newEntity1 = sut.saveOrUpdate(newEntity1);        LtlAccessorialsEntity newEntity2 = TestDataHelper.createLTLAccessorial();        newEntity2 = sut.saveOrUpdate(newEntity2);        LtlAccessorialsEntity newEntity3 = TestDataHelper.createLTLAccessorial();        newEntity3 = sut.saveOrUpdate(newEntity3);        LtlAccessorialsEntity newEntity4 = TestDataHelper.createLTLAccessorial();        newEntity4 = sut.saveOrUpdate(newEntity4);        LtlAccessorialsEntity newEntity5 = TestDataHelper.createLTLAccessorial();        newEntity5 = sut.saveOrUpdate(newEntity5);        flushAndClearSession();        //get updated accessorials by pricing profile detail Id and status.        List<LtlAccessorialsEntity> ltlAccEntities1 =                sut.findActiveAndEffectiveForProfile(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities1);        //Lets first check if the entities count is same. Should be 5        Assert.assertEquals(5, ltlAccEntities1.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(0), newEntity1);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(1), newEntity2);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(2), newEntity3);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(3), newEntity4);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities1.get(4), newEntity5);        // Now lets update the status of 2 of these entities from active to inactive        sut.updateStatuses(Arrays.asList(newEntity1.getId(), newEntity2.getId()), Status.INACTIVE, MODIFIED_BY);        flushAndClearSession();        //Lets play the same game again. Get updated accessorials by pricing profile detail Id and status.        List<LtlAccessorialsEntity> ltlAccEntities2 =                sut.findActiveAndEffectiveForProfile(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities2);        //Lets first check if the entities count is same. Should be 3 as active now is only 3        Assert.assertEquals(3, ltlAccEntities2.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(0), newEntity3);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(1), newEntity4);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(2), newEntity5);        // Oooops.. Its growing big.. Now lets expire active accessorials. Probably one.        newEntity3 = sut.get(newEntity3.getId());        newEntity3.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -15));        newEntity3.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, -10));        sut.saveOrUpdate(newEntity3);        flushAndClearSession();        //Replay. Get updated accessorials by pricing profile detail Id and status.        List<LtlAccessorialsEntity> ltlAccEntities3 =                sut.findActiveAndEffectiveForProfile(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities3);        //Lets first check if the entities count is same. Hey buddy, you have to return me only 2        Assert.assertEquals(2, ltlAccEntities3.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities3.get(0), newEntity4);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities3.get(1), newEntity5);    }    /**     * DAO Method: findExpiredByProfileDetailId(Long profileDetailId).     *     * Oh Boy, will I be done with this one.. Ufffff...     *     * Testcase to test findExpiredByProfileDetailId() Dao method. Will test with first creating profile     * details with active status and no expiration date retrieve records using this method. Should return     * nothing. Now expire three records and retrieve data using this method. Should return 3 records. Go on     * Hima.... Now inactivate one of the expired record, and retrieve data using this method. Should return     * finally only 2 records.     */    @Test    public void testFindExpiredByProfileDetailId() throws EntityNotFoundException {        LtlAccessorialsEntity newEntity1 = TestDataHelper.createLTLAccessorial();        newEntity1 = sut.saveOrUpdate(newEntity1);        LtlAccessorialsEntity newEntity2 = TestDataHelper.createLTLAccessorial();        newEntity2 = sut.saveOrUpdate(newEntity2);        LtlAccessorialsEntity newEntity3 = TestDataHelper.createLTLAccessorial();        newEntity3 = sut.saveOrUpdate(newEntity3);        LtlAccessorialsEntity newEntity4 = TestDataHelper.createLTLAccessorial();        sut.saveOrUpdate(newEntity4);        LtlAccessorialsEntity newEntity5 = TestDataHelper.createLTLAccessorial();        sut.saveOrUpdate(newEntity5);        flushAndClearSession();        //get expired accessorials by pricing profile detail Id.        List<AccessorialListItemVO> ltlAccEntities1 =                sut.findExpiredByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        //returned data size should be zero...        Assert.assertEquals(0, ltlAccEntities1.size());        newEntity1.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -20));        newEntity1.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, -10));        newEntity1 = sut.saveOrUpdate(newEntity1);        newEntity2.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -18));        newEntity2.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, -10));        newEntity2 = sut.saveOrUpdate(newEntity2);        newEntity3.setEffDate(DateUtility.addDays(TestDataHelper.EFF_DATE, -15));        newEntity3.setExpDate(DateUtility.addDays(TestDataHelper.EXP_DATE, -10));        newEntity3 = sut.saveOrUpdate(newEntity3);        flushAndClearSession();        //Get expired accessorials by pricing profile detail Id.        List<AccessorialListItemVO> ltlAccEntities2 =                sut.findExpiredByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities2);        // Lets first check if the entities count is same.        Assert.assertEquals(3, ltlAccEntities2.size());        //Next lets iterate the entites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(0), newEntity1);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(1), newEntity2);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities2.get(2), newEntity3);        //Now lets update the status of 1 of these entities from active to inactive        sut.updateStatuses(Arrays.asList(newEntity1.getId()), Status.INACTIVE, MODIFIED_BY);        flushAndClearSession();        //Again get expired accessorials by pricing profile detail Id - one last time.        List<AccessorialListItemVO> ltlAccEntities3 =                sut.findExpiredByProfileDetailId(TestDataHelper.LTL_PRIC_PROF_DETAIL_ID_1);        Assert.assertNotNull(ltlAccEntities3);        //Lets first check if the entities count is same.        Assert.assertEquals(2, ltlAccEntities3.size());        //Next lets iterate the enitites list and check if they are same as the created object.        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities3.get(0), newEntity2);        assertCreatedAndRetrievedAccessorialWithGeoServices(ltlAccEntities3.get(1), newEntity3);    }    @Test    public void testExpirateByListOfIds() {        Long[] ids = { 1L, 2L };        List<Long> expectedList = Arrays.asList(ids);        sut.expireByListOfIds(expectedList, 1L);        flushAndClearSession();        for (Long id : expectedList) {            LtlAccessorialsEntity actualEntity = sut.find(id);            Assert.assertNotNull(actualEntity);        }    }    @Test    public void testFindAllCspChildsCopyedFrom() {        List<LtlAccessorialsEntity> actualResult = sut.findAllCspChildsCopyedFrom(1L);        Assert.assertNotNull(actualResult);        Assert.assertFalse(actualResult.isEmpty());    }    @Test    public void testExpirateCSPByCopiedFrom() {        List<Long> expectedOwnerIds = Arrays.asList(1L);        Calendar expectedCalendar = Calendar.getInstance();        expectedCalendar.setTime(new Date());        sut.expirateCSPByCopiedFrom(expectedOwnerIds, MODIFIED_BY);        List<LtlAccessorialsEntity> actualCSPList = sut.findAllCspChildsCopyedFrom(1L);        Assert.assertNotNull(actualCSPList);        Assert.assertFalse(actualCSPList.isEmpty());        LtlAccessorialsEntity actualCSPEntity = actualCSPList.get(0);        Calendar actualCalendar = Calendar.getInstance();        actualCalendar.setTime(actualCSPEntity.getExpDate());        Assert.assertEquals(expectedCalendar.get(Calendar.YEAR), actualCalendar.get(Calendar.YEAR));        Assert.assertEquals(expectedCalendar.get(Calendar.MONTH), actualCalendar.get(Calendar.MONTH));        Assert.assertEquals(expectedCalendar.get(Calendar.DATE), actualCalendar.get(Calendar.DATE));    }    @Test    public void testUpdateStatusInCSPByCopiedFrom() {        List<Long> expectedOwnerIds = Arrays.asList(1L);        sut.updateStatusInCSPByCopiedFrom(expectedOwnerIds, Status.INACTIVE, MODIFIED_BY);        List<LtlAccessorialsEntity> actualCSPList = sut.findAllCspChildsCopyedFrom(1L);        Assert.assertNotNull(actualCSPList);        Assert.assertFalse(actualCSPList.isEmpty());        LtlAccessorialsEntity actualEntity = actualCSPList.get(0);        Assert.assertNotNull(actualEntity);        Assert.assertEquals(Status.INACTIVE, actualEntity.getStatus());    }    @Test    public void testInactivateCSPByProfileDetailId() {        sut.inactivateCSPByProfileDetailId(PROFILE_DETAIL_ID, MODIFIED_BY);        flushAndClearSession();        List<LtlAccessorialsEntity> actualList = sut.findAllByProfileDetailId(CHILD_PROFILE_DETAIL_ID);        Assert.assertNotNull(actualList);        Assert.assertFalse(actualList.isEmpty());        for (LtlAccessorialsEntity entity : actualList) {            Assert.assertNotNull(entity);            Assert.assertEquals(Status.INACTIVE, entity.getStatus());        }    }    private void assertCreatedAccessorial(LtlAccessorialsEntity newEntity) {        Assert.assertNotNull(newEntity);        Assert.assertNotNull(newEntity.getId());        flushAndClearSession();        //Using findByprimaryKey DAO method to test the same method.        LtlAccessorialsEntity afterSave = sut.find(newEntity.getId());        Assert.assertNotNull(afterSave);        Assert.assertEquals(newEntity, afterSave);    }    private void assertCreatedAccessorialWithGeoServices(LtlAccessorialsEntity newEntity) {        Assert.assertNotNull(newEntity);        Assert.assertNotNull(newEntity.getId());        flushAndClearSession();        //Using findByprimaryKey DAO method to test the same method.        LtlAccessorialsEntity afterSave = sut.find(newEntity.getId());        Assert.assertNotNull(afterSave);        Assert.assertEquals(newEntity, afterSave);        Assert.assertNotNull(afterSave.getLtlAccGeoServicesEntities());        Assert.assertEquals(newEntity.getLtlAccGeoServicesEntities().size(),                afterSave.getLtlAccGeoServicesEntities().size());        //TODO: Assert each GEO Service created and returned    }    private void assertUpdatedModificationObjectOfAccessorial(LtlAccessorialsEntity newEntity) {        Assert.assertNotNull(newEntity);        Assert.assertNotNull(newEntity.getId());        Assert.assertNotNull(newEntity.getModification().getCreatedBy());        Assert.assertNotNull(newEntity.getModification().getCreatedDate());        Assert.assertNotNull(newEntity.getModification().getModifiedBy());        Assert.assertNotNull(newEntity.getModification().getModifiedDate());//        Assert.assertEquals(CURRENT_USER_PERSON_ID, newEntity.getModification().getCreatedBy());//        Assert.assertEquals(MODIFIED_USER_PERSON_ID, newEntity.getModification().getModifiedBy());    }    private void assertCreatedAndRetrievedAccessorialWithGeoServices(            LtlAccessorialsEntity expectedEntity, LtlAccessorialsEntity createdEntity) {        Assert.assertNotNull(expectedEntity);        Assert.assertNotNull(expectedEntity.getId());        Assert.assertEquals(createdEntity, expectedEntity);        Assert.assertNotNull(expectedEntity.getLtlAccGeoServicesEntities());        Assert.assertEquals(createdEntity.getLtlAccGeoServicesEntities().size(),                expectedEntity.getLtlAccGeoServicesEntities().size());    }    private void assertCreatedAndRetrievedAccessorialWithGeoServices(            AccessorialListItemVO expectedEntity, LtlAccessorialsEntity createdEntity) {        Assert.assertNotNull(expectedEntity);        Assert.assertNotNull(expectedEntity.getId());        Assert.assertEquals(createdEntity.getId(), expectedEntity.getId());        Assert.assertEquals(createdEntity.getAccessorialTypeEntity().getDescription(), expectedEntity.getType());        Assert.assertEquals(createdEntity.getStatus().getCode(), expectedEntity.getStatus());        Assert.assertEquals(0, createdEntity.getMinCost().compareTo(expectedEntity.getMinCost()));        Assert.assertNotNull(expectedEntity.getOrigin());        Assert.assertNotNull(expectedEntity.getDestination());    }}