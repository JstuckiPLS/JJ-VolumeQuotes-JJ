package com.pls.shipment.integration.ltllifecycle.consumer;

import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import javax.annotation.PostConstruct;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import javax.jms.TextMessage;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Profile;
import org.springframework.jms.listener.SessionAwareMessageListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.pls.core.domain.AuditDetailEntity;
import com.pls.core.domain.AuditEntity;
import com.pls.core.domain.sterling.EDIMessageType;
import com.pls.core.service.IntegrationAuditService;
import com.pls.core.service.impl.security.PlsUserDetails;
import com.pls.core.service.impl.security.util.SecurityUtils;
import com.pls.ltlrating.integration.ltllifecycle.dto.message.ShipmentUpdateMessage;
import com.pls.shipment.service.impl.edi.LoadTrackingServiceImpl;

/**
 * Listener of tracking updates generated by LTL-Lifecycle.
 */
@Component("ltllcTrackingIntegrationMessageListener")
@Profile("JMSServer")
@Transactional
public class LtllcTrackingIncomingJMSMessageListener implements SessionAwareMessageListener<Message> {
    private static final Logger LOGGER = LoggerFactory.getLogger(LtllcTrackingIncomingJMSMessageListener.class);
    private static final Character INBOUND_MESSAGE = 'I';

    @Autowired
    @Qualifier("loadTrackingService")
    private LoadTrackingServiceImpl loadTrackingService;

    @Autowired
    private IntegrationAuditService auditService;

    private ObjectMapper om = new ObjectMapper();

    private ConcurrentMap<String, String> loadUUIDs = new ConcurrentHashMap<String, String>();

    @Value("${admin.personId}")
    private Long systemUserId;

    @PostConstruct
    private void init() {
        om.registerModule(new JavaTimeModule());
        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }

    @Override
    public void onMessage(Message message, Session session) throws JMSException {
        String loadUUID = null;
        AuditEntity audit = null;
        try {
            ShipmentUpdateMessage ltllcShipmentUpdateMessage = extractMessage(message);
            authenticateUser();
            audit = populateAudit(ltllcShipmentUpdateMessage);

            loadUUID = ltllcShipmentUpdateMessage.getLoadUUID();
            acquireLock(loadUUID);

            loadTrackingService.processLtllcTrackingMessage(ltllcShipmentUpdateMessage);

            markRequestCompleted(audit);
        } catch (Exception e) {
            markRequestErrored(audit);
            LOGGER.error(e.getMessage(), e);
            throw new RuntimeException("Failed to process incoming LTLLC tracking message.", e);
        } finally {
            if (loadUUID != null) {
                loadUUIDs.remove(loadUUID);
            }
        }
    }

    private void acquireLock(String id) {
        if (id == null) {
            return;
        }
        String putIfAbsent = loadUUIDs.putIfAbsent(id, id);
        while (putIfAbsent != null) {
            try {
                Thread.sleep(500L);
                putIfAbsent = loadUUIDs.putIfAbsent(id, id);
            } catch (InterruptedException e) {
                LOGGER.error(e.getMessage(), e);
            }
        }
    }

    private ShipmentUpdateMessage extractMessage(Message message) throws Exception {
        if (!(message instanceof TextMessage)) {
            throw new Exception("The message type is required to be an instance of TextMessage not: " + message.getClass().getName());
        }
        TextMessage textMessage = (TextMessage) message;
        String jsonString = textMessage.getText();

        return om.readValue(jsonString, ShipmentUpdateMessage.class);
    }

    private void authenticateUser() {
        PlsUserDetails user = new PlsUserDetails("dummy", "dummy", true, new HashSet<String>(), systemUserId, null, false, null);
        SecurityUtils.setupNewAuthentication(user);
    }

    private AuditEntity populateAudit(ShipmentUpdateMessage message) {
        String xml = convertMessage(message);

        AuditEntity audit = new AuditEntity();
        audit.setInbOtb(INBOUND_MESSAGE);
        audit.setMessageType(EDIMessageType.P44_TRACKING);
        audit.setScac(message.getCarrierCode());
        audit.setBol(message.getBolNumber());
        audit.setStatus("P");

        if (StringUtils.isNotEmpty(xml)) {
            AuditDetailEntity detail = new AuditDetailEntity();
            detail.setAudit(audit);
            detail.setMessage(xml);
            audit.setAuditDetail(detail);
        }

        return auditService.saveLog(audit);
    }

    private void markRequestCompleted(AuditEntity audit) {
        audit.setStatus("C");
        auditService.saveLog(audit);
    }

    private void markRequestErrored(AuditEntity audit) {
        if (audit != null) {
            audit.setStatus("E");
            auditService.saveLog(audit);
        }
    }

    private String convertMessage(ShipmentUpdateMessage message) {
        try {
            return om.writeValueAsString(message);
        } catch (JsonProcessingException ex) {
            LOGGER.error("Caught exception while attempting to serialize an instance of ShipmentUpdateMessage: %s", ex.getMessage());
            return "";
        }
    }
}
